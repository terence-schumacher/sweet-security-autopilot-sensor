package main

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/sirupsen/logrus"

	"github.com/invisible-tech/autopilot-security-sensor/pkg/sweetsecurity"
)

var (
	log     = logrus.New()
	version = "0.1.0"
)

// Prometheus metrics
var (
	eventsReceived = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "apss_events_received_total",
			Help: "Total security events received",
		},
		[]string{"type", "severity", "namespace"},
	)

	alertsGenerated = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "apss_alerts_generated_total",
			Help: "Total security alerts generated",
		},
		[]string{"rule", "severity"},
	)

	activeAgents = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "apss_active_agents",
			Help: "Number of active APSS agents",
		},
	)
)

func init() {
	prometheus.MustRegister(eventsReceived)
	prometheus.MustRegister(alertsGenerated)
	prometheus.MustRegister(activeAgents)
}

// DetectionRule defines a rule for detecting suspicious activity
type DetectionRule struct {
	ID          string
	Name        string
	Description string
	Severity    string
	MitreTactic string
	MitreID     string
	Condition   func(event *SecurityEvent) bool
	Actions     []string
}

// SecurityEvent from agents
type SecurityEvent struct {
	ID           string                 `json:"id"`
	AgentID      string                 `json:"agent_id"`
	Type         string                 `json:"type"`
	Severity     string                 `json:"severity"`
	Timestamp    time.Time              `json:"timestamp"`
	PodName      string                 `json:"pod_name"`
	PodNamespace string                 `json:"pod_namespace"`
	Process      *ProcessEventData      `json:"process,omitempty"`
	Network      *NetworkEventData      `json:"network,omitempty"`
	File         *FileEventData         `json:"file,omitempty"`
	Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

type ProcessEventData struct {
	PID                  int      `json:"pid"`
	PPID                 int      `json:"ppid"`
	Name                 string   `json:"name"`
	Cmdline              []string `json:"cmdline"`
	SuspiciousIndicators []string `json:"suspicious_indicators,omitempty"`
}

type NetworkEventData struct {
	Protocol         string `json:"protocol"`
	DstIP            string `json:"dst_ip"`
	DstPort          int    `json:"dst_port"`
	State            string `json:"state"`
	IsExternal       bool   `json:"is_external"`
	IsSuspiciousPort bool   `json:"is_suspicious_port"`
}

type FileEventData struct {
	Path      string `json:"path"`
	Operation string `json:"operation"`
	OldHash   string `json:"old_hash,omitempty"`
	NewHash   string `json:"new_hash,omitempty"`
}

// Alert generated by detection rules
type Alert struct {
	ID          string    `json:"id"`
	Timestamp   time.Time `json:"timestamp"`
	Severity    string    `json:"severity"`
	RuleID      string    `json:"rule_id"`
	RuleName    string    `json:"rule_name"`
	Description string    `json:"description"`
	EventIDs    []string  `json:"event_ids"`
	PodName     string    `json:"pod_name"`
	PodNS       string    `json:"pod_namespace"`
	MitreTactic string    `json:"mitre_tactic,omitempty"`
	MitreID     string    `json:"mitre_id,omitempty"`
	Actions     []string  `json:"recommended_actions"`
}

// AgentInfo tracks connected agents
type AgentInfo struct {
	ID           string
	PodName      string
	PodNamespace string
	ConnectedAt  time.Time
	LastSeen     time.Time
	EventCount   int64
}

// Controller orchestrates event processing and detection
type Controller struct {
	rules          []*DetectionRule
	agents         map[string]*AgentInfo
	agentsMu       sync.RWMutex
	alerts         []Alert
	alertsMu       sync.RWMutex
	eventBuffer    chan *SecurityEvent
	alertChan      chan *Alert
	sweetSecurity   *sweetsecurity.Client
	sweetSecurityMu sync.RWMutex
}

// NewController creates a new controller
func NewController() *Controller {
	c := &Controller{
		agents:      make(map[string]*AgentInfo),
		eventBuffer: make(chan *SecurityEvent, 100000),
		alertChan:   make(chan *Alert, 10000),
	}
	c.loadDetectionRules()
	c.initSweetSecurity()
	return c
}

// initSweetSecurity initializes Sweet Security client if configured
func (c *Controller) initSweetSecurity() {
	endpoint := os.Getenv("SWEET_SECURITY_ENDPOINT")
	apiKey := os.Getenv("SWEET_SECURITY_API_KEY")

	if endpoint == "" || apiKey == "" {
		log.Debug("Sweet Security integration not configured (missing endpoint or API key)")
		return
	}

	client := sweetsecurity.NewClient(sweetsecurity.Config{
		APIEndpoint: endpoint,
		APIKey:      apiKey,
		Timeout:     30 * time.Second,
	}, log)

	c.sweetSecurityMu.Lock()
	c.sweetSecurity = client
	c.sweetSecurityMu.Unlock()

	// Test connection in background
	go func() {
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		if err := client.HealthCheck(ctx); err != nil {
			log.WithError(err).Warn("Sweet Security health check failed, will retry on first alert")
		} else {
			log.Info("Sweet Security API connection verified")
		}
	}()
}

// loadDetectionRules initializes detection rules
func (c *Controller) loadDetectionRules() {
	c.rules = []*DetectionRule{
		{
			ID:          "APSS-001",
			Name:        "Potential Reverse Shell",
			Description: "Detected network connection matching reverse shell pattern",
			Severity:    "CRITICAL",
			MitreTactic: "Command and Control",
			MitreID:     "T1059.004",
			Condition: func(e *SecurityEvent) bool {
				if e.Network == nil {
					return false
				}
				suspiciousPorts := map[int]bool{4444: true, 5555: true, 6666: true, 1337: true}
				return e.Network.IsExternal && suspiciousPorts[e.Network.DstPort]
			},
			Actions: []string{"Investigate pod immediately", "Check for unauthorized processes", "Review pod logs"},
		},
		{
			ID:          "APSS-002",
			Name:        "Cryptominer Detected",
			Description: "Process matching known cryptocurrency miner patterns",
			Severity:    "CRITICAL",
			MitreTactic: "Impact",
			MitreID:     "T1496",
			Condition: func(e *SecurityEvent) bool {
				if e.Process == nil {
					return false
				}
				for _, ind := range e.Process.SuspiciousIndicators {
					if ind == "possible_cryptominer" {
						return true
					}
				}
				return false
			},
			Actions: []string{"Terminate pod", "Investigate container image", "Review deployment source"},
		},
		{
			ID:          "APSS-003",
			Name:        "Sensitive File Modified",
			Description: "Critical system file was modified",
			Severity:    "HIGH",
			MitreTactic: "Persistence",
			MitreID:     "T1546",
			Condition: func(e *SecurityEvent) bool {
				if e.File == nil {
					return false
				}
				criticalPaths := []string{"/etc/passwd", "/etc/shadow", "/etc/sudoers"}
				for _, p := range criticalPaths {
					if e.File.Path == p && e.File.Operation == "modify" {
						return true
					}
				}
				return false
			},
			Actions: []string{"Review file changes", "Check for privilege escalation", "Audit container"},
		},
		{
			ID:          "APSS-004",
			Name:        "Shell Spawned in Container",
			Description: "Interactive shell was spawned inside container",
			Severity:    "MEDIUM",
			MitreTactic: "Execution",
			MitreID:     "T1059",
			Condition: func(e *SecurityEvent) bool {
				if e.Process == nil {
					return false
				}
				for _, ind := range e.Process.SuspiciousIndicators {
					if ind == "shell_spawn" {
						return true
					}
				}
				return false
			},
			Actions: []string{"Verify if expected (kubectl exec)", "Review user activity", "Check for lateral movement"},
		},
		{
			ID:          "APSS-005",
			Name:        "External Database Connection",
			Description: "Connection to external database detected",
			Severity:    "MEDIUM",
			MitreTactic: "Exfiltration",
			MitreID:     "T1048",
			Condition: func(e *SecurityEvent) bool {
				if e.Network == nil {
					return false
				}
				dbPorts := map[int]bool{3306: true, 5432: true, 27017: true, 6379: true, 9200: true}
				return e.Network.IsExternal && dbPorts[e.Network.DstPort]
			},
			Actions: []string{"Verify database connection is authorized", "Review network policies", "Check for data exfiltration"},
		},
	}
}

// Start begins the controller
func (c *Controller) Start(ctx context.Context) error {
	log.Info("Starting APSS Controller")

	// Start event processor
	go c.processEvents(ctx)

	// Start alert processor
	go c.processAlerts(ctx)

	// Start agent health checker
	go c.checkAgentHealth(ctx)

	// Setup HTTP server
	mux := http.NewServeMux()
	mux.HandleFunc("/health", c.handleHealth)
	mux.HandleFunc("/api/v1/events", c.handleEvents)
	mux.HandleFunc("/api/v1/agents", c.handleAgents)
	mux.HandleFunc("/api/v1/alerts", c.handleAlerts)
	mux.Handle("/metrics", promhttp.Handler())

	server := &http.Server{
		Addr:    ":8080",
		Handler: mux,
	}

	go func() {
		<-ctx.Done()
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()
		server.Shutdown(shutdownCtx)
	}()

	log.Info("Controller listening on :8080")
	return server.ListenAndServe()
}

// processEvents processes incoming security events
func (c *Controller) processEvents(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case event := <-c.eventBuffer:
			c.evaluateEvent(event)
		}
	}
}

// evaluateEvent runs detection rules against an event
func (c *Controller) evaluateEvent(event *SecurityEvent) {
	eventsReceived.WithLabelValues(event.Type, event.Severity, event.PodNamespace).Inc()

	for _, rule := range c.rules {
		if rule.Condition(event) {
			alert := &Alert{
				ID:          fmt.Sprintf("alert-%d", time.Now().UnixNano()),
				Timestamp:   time.Now(),
				Severity:    rule.Severity,
				RuleID:      rule.ID,
				RuleName:    rule.Name,
				Description: rule.Description,
				EventIDs:    []string{event.ID},
				PodName:     event.PodName,
				PodNS:       event.PodNamespace,
				MitreTactic: rule.MitreTactic,
				MitreID:     rule.MitreID,
				Actions:     rule.Actions,
			}

			select {
			case c.alertChan <- alert:
			default:
				log.Warn("Alert channel full, dropping alert")
			}
		}
	}
}

// processAlerts handles generated alerts
func (c *Controller) processAlerts(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case alert := <-c.alertChan:
			c.alertsMu.Lock()
			c.alerts = append(c.alerts, *alert)
			// Keep last 10000 alerts
			if len(c.alerts) > 10000 {
				c.alerts = c.alerts[len(c.alerts)-10000:]
			}
			c.alertsMu.Unlock()

			alertsGenerated.WithLabelValues(alert.RuleID, alert.Severity).Inc()

			// Log the alert
			log.WithFields(logrus.Fields{
				"alert_id":    alert.ID,
				"rule_id":     alert.RuleID,
				"rule_name":   alert.RuleName,
				"severity":    alert.Severity,
				"pod":         alert.PodName,
				"namespace":   alert.PodNS,
				"mitre":       alert.MitreID,
				"description": alert.Description,
			}).Warn("SECURITY ALERT")

			// Send to Sweet Security API if configured
			c.sendToSweetSecurity(ctx, alert)
		}
	}
}

// sendToSweetSecurity sends alert to Sweet Security API
func (c *Controller) sendToSweetSecurity(ctx context.Context, alert *Alert) {
	c.sweetSecurityMu.RLock()
	client := c.sweetSecurity
	c.sweetSecurityMu.RUnlock()

	if client == nil {
		return // Not configured
	}

	// Convert internal alert to Sweet Security format
	sweetAlert := &sweetsecurity.Alert{
		ID:           alert.ID,
		Timestamp:    alert.Timestamp,
		Severity:     alert.Severity,
		RuleID:       alert.RuleID,
		RuleName:     alert.RuleName,
		Description:  alert.Description,
		PodName:      alert.PodName,
		PodNamespace: alert.PodNS,
		MitreTactic:  alert.MitreTactic,
		MitreID:      alert.MitreID,
		EventIDs:     alert.EventIDs,
		Metadata: map[string]interface{}{
			"source":        "apss-autopilot-security-sensor",
			"recommended_actions": alert.Actions,
		},
	}

	// Send asynchronously to avoid blocking alert processing
	go func() {
		if err := client.SendAlert(ctx, sweetAlert); err != nil {
			log.WithError(err).WithFields(logrus.Fields{
				"alert_id": alert.ID,
				"rule_id":  alert.RuleID,
			}).Error("Failed to send alert to Sweet Security API")
		} else {
			log.WithFields(logrus.Fields{
				"alert_id": alert.ID,
				"rule_id":  alert.RuleID,
			}).Debug("Alert sent to Sweet Security API")
		}
	}()
}

// checkAgentHealth monitors agent health
func (c *Controller) checkAgentHealth(ctx context.Context) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			c.agentsMu.Lock()
			now := time.Now()
			for id, agent := range c.agents {
				if now.Sub(agent.LastSeen) > 2*time.Minute {
					log.WithField("agent_id", id).Warn("Agent appears offline")
					delete(c.agents, id)
				}
			}
			activeAgents.Set(float64(len(c.agents)))
			c.agentsMu.Unlock()
		}
	}
}

// HTTP Handlers
func (c *Controller) handleHealth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "healthy", "version": version})
}

func (c *Controller) handleEvents(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var event SecurityEvent
	if err := json.NewDecoder(r.Body).Decode(&event); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	// Update agent info
	c.agentsMu.Lock()
	if agent, ok := c.agents[event.AgentID]; ok {
		agent.LastSeen = time.Now()
		agent.EventCount++
	} else {
		c.agents[event.AgentID] = &AgentInfo{
			ID:           event.AgentID,
			PodName:      event.PodName,
			PodNamespace: event.PodNamespace,
			ConnectedAt:  time.Now(),
			LastSeen:     time.Now(),
			EventCount:   1,
		}
	}
	c.agentsMu.Unlock()

	// Send high-severity events to Sweet Security if configured
	if event.Severity == "CRITICAL" || event.Severity == "HIGH" {
		c.sendEventToSweetSecurity(r.Context(), &event)
	}

	// Queue event for processing
	select {
	case c.eventBuffer <- &event:
		w.WriteHeader(http.StatusAccepted)
	default:
		http.Error(w, "Event buffer full", http.StatusServiceUnavailable)
	}
}

// sendEventToSweetSecurity sends high-severity events to Sweet Security
func (c *Controller) sendEventToSweetSecurity(ctx context.Context, event *SecurityEvent) {
	c.sweetSecurityMu.RLock()
	client := c.sweetSecurity
	c.sweetSecurityMu.RUnlock()

	if client == nil {
		return // Not configured
	}

	// Convert to Sweet Security event format
	sweetEvent := &sweetsecurity.Event{
		ID:           event.ID,
		AgentID:      event.AgentID,
		Type:         event.Type,
		Severity:     event.Severity,
		Timestamp:    event.Timestamp,
		PodName:      event.PodName,
		PodNamespace: event.PodNamespace,
		Metadata:     make(map[string]interface{}),
	}

	// Convert process data
	if event.Process != nil {
		sweetEvent.Process = map[string]interface{}{
			"pid":                   event.Process.PID,
			"ppid":                  event.Process.PPID,
			"name":                  event.Process.Name,
			"cmdline":               event.Process.Cmdline,
			"suspicious_indicators": event.Process.SuspiciousIndicators,
		}
	}

	// Convert network data
	if event.Network != nil {
		sweetEvent.Network = map[string]interface{}{
			"protocol":          event.Network.Protocol,
			"dst_ip":            event.Network.DstIP,
			"dst_port":          event.Network.DstPort,
			"state":             event.Network.State,
			"is_external":        event.Network.IsExternal,
			"is_suspicious_port": event.Network.IsSuspiciousPort,
		}
	}

	// Convert file data
	if event.File != nil {
		sweetEvent.File = map[string]interface{}{
			"path":      event.File.Path,
			"operation": event.File.Operation,
			"old_hash":  event.File.OldHash,
			"new_hash":  event.File.NewHash,
		}
	}

	// Add metadata
	if event.Metadata != nil {
		for k, v := range event.Metadata {
			sweetEvent.Metadata[k] = v
		}
	}

	// Send asynchronously
	go func() {
		if err := client.SendEvent(ctx, sweetEvent); err != nil {
			log.WithError(err).WithField("event_id", event.ID).Debug("Failed to send event to Sweet Security")
		}
	}()
}

func (c *Controller) handleAgents(w http.ResponseWriter, r *http.Request) {
	c.agentsMu.RLock()
	defer c.agentsMu.RUnlock()

	agents := make([]*AgentInfo, 0, len(c.agents))
	for _, a := range c.agents {
		agents = append(agents, a)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(agents)
}

func (c *Controller) handleAlerts(w http.ResponseWriter, r *http.Request) {
	c.alertsMu.RLock()
	defer c.alertsMu.RUnlock()

	// Return last 100 alerts
	start := 0
	if len(c.alerts) > 100 {
		start = len(c.alerts) - 100
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(c.alerts[start:])
}

func main() {
	log.SetFormatter(&logrus.JSONFormatter{})
	log.SetLevel(logrus.InfoLevel)

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	controller := NewController()

	go func() {
		<-sigChan
		log.Info("Shutting down controller")
		cancel()
	}()

	if err := controller.Start(ctx); err != http.ErrServerClosed {
		log.WithError(err).Fatal("Controller failed")
	}
}
